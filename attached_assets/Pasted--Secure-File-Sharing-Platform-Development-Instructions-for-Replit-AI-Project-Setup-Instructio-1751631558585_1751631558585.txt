🔐 Secure File Sharing Platform - Development Instructions for Replit AI
📋 Project Setup Instructions
Project Type: Next.js 14 Frontend + Node.js/Express Backend + Prisma + Neon PostgreSQL + TypeScript
Structure: Separate frontend and backend applications
🎯 Core Application Requirements
Primary Features to Build:

File Upload Interface - Drag & drop with shadcn/ui components
Client-Side Encryption - Encrypt files before upload using Web Crypto API
Secure Link Generation - Create unique sharing URLs with embedded keys
File Download/Decryption - Automatic decryption for recipients
Automatic Cleanup - Files expire after 24 hours

Security Requirements:

All encryption happens client-side (browser)
Server never sees plaintext files
Use AES-256-GCM for file encryption
Generate ephemeral key pairs for each file
Implement secure memory cleanup

🛠️ Project Structure
secure-file-share/
├── frontend/                 # Next.js 14 with App Router
│   ├── src/
│   │   ├── app/
│   │   │   ├── page.tsx
│   │   │   ├── upload/
│   │   │   ├── download/[id]/
│   │   │   └── layout.tsx
│   │   ├── components/
│   │   │   ├── ui/           # shadcn/ui components
│   │   │   ├── FileUpload.tsx
│   │   │   ├── FileDownload.tsx
│   │   │   └── ShareLink.tsx
│   │   ├── lib/
│   │   │   ├── crypto.ts
│   │   │   ├── api.ts
│   │   │   └── utils.ts
│   │   └── types/
│   ├── package.json
│   └── next.config.js
├── backend/                  # Node.js/Express API
│   ├── src/
│   │   ├── routes/
│   │   │   ├── files.ts
│   │   │   └── health.ts
│   │   ├── middleware/
│   │   │   ├── auth.ts
│   │   │   ├── upload.ts
│   │   │   └── rateLimit.ts
│   │   ├── services/
│   │   │   ├── fileService.ts
│   │   │   └── cleanupService.ts
│   │   ├── utils/
│   │   │   └── validation.ts
│   │   ├── prisma/
│   │   │   └── schema.prisma
│   │   └── server.ts
│   ├── package.json
│   └── uploads/              # Encrypted files storage
└── README.md
🗄️ Backend Setup (Node.js/Express)
package.json (Backend)
json{
  "name": "secure-file-share-backend",
  "version": "1.0.0",
  "scripts": {
    "dev": "nodemon src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "db:push": "prisma db push",
    "db:generate": "prisma generate"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "multer": "^1.4.5-lts.1",
    "uuid": "^9.0.0",
    "bcrypt": "^5.1.0",
    "jsonwebtoken": "^9.0.0",
    "helmet": "^7.0.0",
    "express-rate-limit": "^6.7.0",
    "node-cron": "^3.0.2",
    "dotenv": "^16.0.3",
    "prisma": "^5.0.0",
    "@prisma/client": "^5.0.0",
    "zod": "^3.21.4"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "nodemon": "^2.0.22",
    "ts-node": "^10.9.0",
    "@types/express": "^4.17.17",
    "@types/cors": "^2.8.13",
    "@types/multer": "^1.4.7",
    "@types/uuid": "^9.0.0",
    "@types/bcrypt": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.0",
    "@types/node-cron": "^3.0.7"
  }
}
Database Schema (Prisma)
prisma// backend/src/prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model File {
  id            String   @id @default(cuid())
  filename      String
  originalName  String
  fileSize      Int
  mimeType      String
  encryptedPath String   // Path to encrypted file
  publicKey     String   // Sender's public key for decryption
  uploadDate    DateTime @default(now())
  expiryDate    DateTime
  downloadCount Int      @default(0)
  maxDownloads  Int      @default(1)
  isExpired     Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("files")
}
Environment Variables (.env)
envDATABASE_URL="postgresql://username:password@localhost:5432/secure_files?schema=public"
PORT=3001
JWT_SECRET=your-super-secret-jwt-key
NODE_ENV=development
UPLOAD_DIR=./uploads
MAX_FILE_SIZE=104857600  # 100MB
🔧 Backend Implementation
Main Server (src/server.ts)
typescriptimport express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';
import { PrismaClient } from '@prisma/client';
import fileRoutes from './routes/files';
import { cleanupExpiredFiles } from './services/cleanupService';
import cron from 'node-cron';

dotenv.config();

const app = express();
const prisma = new PrismaClient();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));
app.use(express.json({ limit: '100mb' }));

// Routes
app.use('/api/files', fileRoutes);

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

// Schedule cleanup every hour
cron.schedule('0 * * * *', async () => {
  console.log('Running cleanup task...');
  await cleanupExpiredFiles();
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
File Routes (src/routes/files.ts)
typescriptimport { Router } from 'express';
import multer from 'multer';
import { PrismaClient } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import fs from 'fs';
import rateLimit from 'express-rate-limit';

const router = Router();
const prisma = new PrismaClient();

// Rate limiting
const uploadLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // 10 uploads per window
  message: 'Too many uploads, please try again later'
});

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = process.env.UPLOAD_DIR || './uploads';
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueName = `${uuidv4()}.enc`;
    cb(null, uniqueName);
  }
});

const upload = multer({
  storage,
  limits: { fileSize: parseInt(process.env.MAX_FILE_SIZE || '104857600') },
  fileFilter: (req, file, cb) => {
    // Accept all files since they're encrypted
    cb(null, true);
  }
});

// Upload encrypted file
router.post('/upload', uploadLimit, upload.single('file'), async (req, res) => {
  try {
    const { originalName, fileSize, mimeType, publicKey, maxDownloads = 1 } = req.body;
    
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    // Set expiry to 24 hours from now
    const expiryDate = new Date(Date.now() + 24 * 60 * 60 * 1000);

    const fileRecord = await prisma.file.create({
      data: {
        filename: req.file.filename,
        originalName,
        fileSize: parseInt(fileSize),
        mimeType,
        encryptedPath: req.file.path,
        publicKey,
        expiryDate,
        maxDownloads: parseInt(maxDownloads)
      }
    });

    res.json({
      success: true,
      fileId: fileRecord.id,
      expiryDate: fileRecord.expiryDate
    });
  } catch (error) {
    console.error('Upload error:', error);
    res.status(500).json({ error: 'Upload failed' });
  }
});

// Download encrypted file
router.get('/download/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const file = await prisma.file.findUnique({
      where: { id }
    });

    if (!file) {
      return res.status(404).json({ error: 'File not found' });
    }

    // Check if file is expired
    if (file.isExpired || new Date() > file.expiryDate) {
      return res.status(410).json({ error: 'File has expired' });
    }

    // Check download limit
    if (file.downloadCount >= file.maxDownloads) {
      return res.status(410).json({ error: 'Download limit reached' });
    }

    // Check if file exists on disk
    if (!fs.existsSync(file.encryptedPath)) {
      return res.status(404).json({ error: 'File not found on disk' });
    }

    // Update download count
    await prisma.file.update({
      where: { id },
      data: { downloadCount: file.downloadCount + 1 }
    });

    // Send file metadata and encrypted blob
    res.json({
      success: true,
      file: {
        id: file.id,
        originalName: file.originalName,
        fileSize: file.fileSize,
        mimeType: file.mimeType,
        publicKey: file.publicKey,
        downloadCount: file.downloadCount + 1,
        maxDownloads: file.maxDownloads
      },
      encryptedData: fs.readFileSync(file.encryptedPath, 'base64')
    });
  } catch (error) {
    console.error('Download error:', error);
    res.status(500).json({ error: 'Download failed' });
  }
});

// Get file metadata
router.get('/info/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const file = await prisma.file.findUnique({
      where: { id },
      select: {
        id: true,
        originalName: true,
        fileSize: true,
        mimeType: true,
        uploadDate: true,
        expiryDate: true,
        downloadCount: true,
        maxDownloads: true,
        isExpired: true
      }
    });

    if (!file) {
      return res.status(404).json({ error: 'File not found' });
    }

    res.json({ success: true, file });
  } catch (error) {
    console.error('Info error:', error);
    res.status(500).json({ error: 'Failed to get file info' });
  }
});

export default router;
🎨 Frontend Setup (Next.js)
package.json (Frontend)
json{
  "name": "secure-file-share-frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript": "^5.0.0",
    "@types/node": "^20.0.0",
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "tailwindcss": "^3.3.0",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.0.0",
    "tailwind-merge": "^2.0.0",
    "lucide-react": "^0.263.0",
    "react-dropzone": "^14.0.0",
    "qrcode": "^1.5.3",
    "@types/qrcode": "^1.5.0"
  },
  "devDependencies": {
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.31",
    "eslint": "^8.0.0",
    "eslint-config-next": "14.0.0"
  }
}
Client-Side Crypto Library (src/lib/crypto.ts)
typescript// Encryption utilities using Web Crypto API
export class FileEncryption {
  // Generate key pair for file encryption
  static async generateKeyPair(): Promise<CryptoKeyPair> {
    return await crypto.subtle.generateKey(
      {
        name: 'ECDH',
        namedCurve: 'P-256'
      },
      true,
      ['deriveKey']
    );
  }

  // Encrypt file with AES-256-GCM
  static async encryptFile(file: File, publicKey: CryptoKey): Promise<{
    encryptedData: ArrayBuffer;
    iv: Uint8Array;
    publicKeyJwk: JsonWebKey;
  }> {
    const keyPair = await this.generateKeyPair();
    
    // Derive shared secret
    const sharedSecret = await crypto.subtle.deriveKey(
      {
        name: 'ECDH',
        public: publicKey
      },
      keyPair.privateKey,
      {
        name: 'AES-GCM',
        length: 256
      },
      false,
      ['encrypt']
    );

    // Generate random IV
    const iv = crypto.getRandomValues(new Uint8Array(12));
    
    // Read file as ArrayBuffer
    const fileData = await file.arrayBuffer();
    
    // Encrypt file
    const encryptedData = await crypto.subtle.encrypt(
      {
        name: 'AES-GCM',
        iv: iv
      },
      sharedSecret,
      fileData
    );

    // Export public key
    const publicKeyJwk = await crypto.subtle.exportKey('jwk', keyPair.publicKey);

    return {
      encryptedData,
      iv,
      publicKeyJwk
    };
  }

  // Decrypt file
  static async decryptFile(
    encryptedData: ArrayBuffer,
    iv: Uint8Array,
    senderPublicKeyJwk: JsonWebKey,
    filename: string
  ): Promise<void> {
    const keyPair = await this.generateKeyPair();
    
    // Import sender's public key
    const senderPublicKey = await crypto.subtle.importKey(
      'jwk',
      senderPublicKeyJwk,
      {
        name: 'ECDH',
        namedCurve: 'P-256'
      },
      false,
      []
    );

    // Derive shared secret
    const sharedSecret = await crypto.subtle.deriveKey(
      {
        name: 'ECDH',
        public: senderPublicKey
      },
      keyPair.privateKey,
      {
        name: 'AES-GCM',
        length: 256
      },
      false,
      ['decrypt']
    );

    // Decrypt file
    const decryptedData = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: iv
      },
      sharedSecret,
      encryptedData
    );

    // Download decrypted file
    const blob = new Blob([decryptedData]);
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }
}
🚀 Key Implementation Points
1. File Upload Flow
typescript// 1. User selects file
// 2. Generate key pair client-side
// 3. Encrypt file with AES-256-GCM
// 4. Upload encrypted blob to server
// 5. Store metadata in database
// 6. Generate sharing link with public key
2. File Download Flow
typescript// 1. User clicks sharing link
// 2. Extract file ID and public key from URL
// 3. Fetch encrypted file from server
// 4. Decrypt file client-side
// 5. Trigger download of plaintext file
3. Security Features

Zero-knowledge: Server never sees plaintext
Ephemeral keys: New key pair for each file
Automatic expiry: Files deleted after 24 hours
Download limits: Configurable max downloads
Rate limiting: Prevent abuse

4. UI Components (shadcn/ui)
bash# Install required shadcn components
npx shadcn-ui@latest init
npx shadcn-ui@latest add button
npx shadcn-ui@latest add card
npx shadcn-ui@latest add progress
npx shadcn-ui@latest add alert
npx shadcn-ui@latest add input
🔧 Development Steps

Setup Backend: Express server with Prisma and PostgreSQL
Setup Frontend: Next.js with TypeScript and shadcn/ui
Implement Crypto: Web Crypto API for encryption/decryption
Build Upload: File upload with client-side encryption
Build Download: File download with client-side decryption
Add Security: Rate limiting, validation, cleanup
Polish UI: Drag & drop, progress bars, QR codes

This setup provides a complete secure file sharing platform with modern tech stack and strong security principles